
## 1. Что такое перечисление (`enum`)

**Перечисление (enumeration, `enum`)** — это пользовательский тип данных, который может принимать **одно из заранее перечисленных именованных значений**.

```cpp
enum Color {
    Red,
    Green,
    Blue
};
```

Здесь:

- `Color` — новый тип
    
- `Red`, `Green`, `Blue` — его значения (enumerators)
    

---

## 2. Зачем нужны `enum`

- улучшение читаемости кода
    
- ограничение допустимых значений
    
- замена «магических чисел»
    
- логическое объединение связанных констант
    

---

## 3. Правила присваивания значений в enum

### 3.1. Значения по умолчанию

Если значения **не указаны явно**:

```cpp
enum Color {
    Red,    // 0
    Green,  // 1
    Blue    // 2
};
```

Правила:

- первый элемент = `0`
    
- каждый следующий = предыдущий + 1
    

---

### 3.2. Явное задание значений

```cpp
enum ErrorCode {
    Ok = 0,
    NotFound = 404,
    Forbidden = 403,
    InternalError = 500
};
```

---

### 3.3. Частично заданные значения

```cpp
enum Numbers {
    A = 1,
    B,       // 2
    C = 10,
    D        // 11
};
```

---

## 4. Как вычисляются значения перечисления

Значения:

- вычисляются **на этапе компиляции**
    
- являются **целочисленными константами**
    

```cpp
enum Flags {
    Read  = 1 << 0,  // 1
    Write = 1 << 1,  // 2
    Exec  = 1 << 2   // 4
};
```

Используется для битовых флагов.

---

## 5. Ограничения на значения enum

### 5.1. Только целочисленные значения

- значения enum — **целые числа**
    
- нельзя использовать `double`, `std::string` и т.п.
    

```cpp
enum Bad {
    A = 3.14; // ❌ ошибка
};
```

---

### 5.2. Диапазон значений

Диапазон значений ограничен **базовым (underlying) типом**.

Например:

```cpp
enum Small : unsigned char {
    A = 0,
    B = 255
};
```

---

## 6. Базовый (underlying) тип перечисления

### 6.1. Что это такое

**Underlying type** — это целочисленный тип, в котором **фактически хранится значение enum**.

---

### 6.2. Для обычного enum (unscoped enum)

```cpp
enum Color {
    Red, Green, Blue
};
```

- тип выбирается **компилятором**
    
- обычно `int`
    
- но стандарт гарантирует только, что тип:
    
    - целочисленный
        
    - способен вместить все значения enum
        

---

### 6.3. Явное задание базового типа

```cpp
enum Color : std::uint8_t {
    Red, Green, Blue
};
```

✔ уменьшает размер  
✔ полезно для сериализации и сетевых протоколов

---

## 7. enum class (scoped enum) — кратко для контекста

Хотя вопрос про `enum`, на экзамене часто спрашивают сравнение.

```cpp
enum class Color {
    Red,
    Green,
    Blue
};
```

Отличия:

- значения находятся в области видимости `Color::Red`
    
- **нет неявного преобразования в int**
    
- более строгая типобезопасность
    

---

## 8. Преобразование enum в int

### Обычный enum

```cpp
Color c = Red;
int x = c; // ✅
```

### enum class

```cpp
Color c = Color::Red;
int x = static_cast<int>(c); // обязательно
```

---

## 9. Размер enum

```cpp
enum A { X, Y };
sizeof(A); // обычно sizeof(int)
```

Но:

```cpp
enum A : std::uint8_t { X, Y };
sizeof(A) == 1;
```

---

## 10. Типичные ошибки студентов

❌ Ожидание, что enum проверяет диапазон значений во время выполнения  
❌ Использование обычного enum вместо enum class  
❌ Хранение несвязанных значений в одном enum  
❌ Надежда на конкретный underlying type без явного указания

---

## 11. Краткое резюме

- `enum` — пользовательский целочисленный тип с именованными значениями
    
- значения вычисляются на этапе компиляции
    
- по умолчанию: 0, 1, 2, ...
    
- можно задавать значения явно
    
- значения ограничены базовым типом
    
- базовый тип можно указать явно
    
- `enum class` безопаснее обычного `enum`
    