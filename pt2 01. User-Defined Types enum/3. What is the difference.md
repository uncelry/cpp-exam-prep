
## 1. Обычный `enum` (unscoped enum)

### Пример

```cpp
enum Color {
    Red,
    Green,
    Blue
};
```

### Свойства

- значения попадают в **внешнюю область видимости**
    
- **разрешено неявное преобразование в `int`**
    
- слабая типобезопасность
    
- возможны конфликты имён
    

```cpp
int x = Red;   // ✅
```

---

## 2. `enum class` (scoped enum, C++11+)

### Пример

```cpp
enum class Color {
    Red,
    Green,
    Blue
};
```

Использование:

```cpp
Color c = Color::Red;
```

### Свойства

- значения находятся в области видимости enum (`Color::Red`)
    
- **запрещено неявное преобразование в int**
    
- строгая типизация
    
- можно явно задать базовый тип
    

---

## 3. Главное различие — область видимости

### enum

```cpp
enum Status {
    Ok,
    Error
};

int x = Ok; // доступно напрямую
```

### enum class

```cpp
enum class Status {
    Ok,
    Error
};

int x = Status::Ok; // ❌
int y = static_cast<int>(Status::Ok); // ✅
```

---

## 4. Неявные преобразования в обычном enum

### Почему они разрешены

Исторически:

- C++ унаследовал поведение enum из C
    
- enum рассматривался как «именованные int»
    

```cpp
enum A { X = 10 };
int v = X;  // допустимо
```

### Проблемы

```cpp
enum Color { Red = 1 };
enum Error { Red = 100 }; // ❌ конфликт имён
```

```cpp
void f(int);
f(Red); // ❌ логическая ошибка, но компилируется
```

---

## 5. Почему enum class запрещает неявные преобразования

### Причины

1. **Типобезопасность**
    
2. Защита от случайных ошибок
    
3. Чёткий интерфейс
    
4. Совместимость с перегрузкой функций
    

---

### Пример ошибки, которую предотвращает enum class

```cpp
enum class Color { Red };
enum class Error { Red };

void f(Color);
void f(Error);

f(Color::Red); // однозначно
```

С обычным enum это невозможно.

---

## 6. Явное преобразование enum class → int

```cpp
int x = static_cast<int>(Color::Red);
```

✔ программист осознанно соглашается на потерю типобезопасности  
✔ код становится понятнее

---

## 7. enum class и базовый тип

```cpp
enum class Color : std::uint8_t {
    Red = 1,
    Green = 2
};
```

Преимущества:

- контроль размера
    
- удобство сериализации
    
- сетевые протоколы
    

---

## 8. Сравнение в таблице

|Характеристика|enum|enum class|
|---|---|---|
|Область видимости|Глобальная|Scoped|
|Неявное преобразование в int|Да|Нет|
|Типобезопасность|Низкая|Высокая|
|Конфликты имён|Возможны|Исключены|
|Перегрузка функций|Проблемы|Корректно|
|Рекомендуемость|❌|✅|

---

## 9. Когда использовать обычный enum

Редко:

- совместимость с C API
    
- старый код
    
- низкоуровневые битовые флаги (иногда)
    

Во всех остальных случаях → **`enum class`**

---

## 10. Типичные экзаменационные вопросы

✔ Почему enum class безопаснее?  
✔ Почему нельзя неявно привести enum class к int?  
✔ Как получить int из enum class?  
✔ Можно ли задать базовый тип?

---

## 11. Краткое резюме

- `enum` — устаревший, слаботипизированный
    
- `enum class` — современный, безопасный
    
- enum → int: неявно
    
- enum class → int: только явно
    
- enum class предотвращает логические ошибки
    
