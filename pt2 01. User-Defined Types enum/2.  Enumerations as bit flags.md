
## 1. Что такое битовые флаги

**Битовые флаги** — это способ хранить **несколько логических состояний (true/false)** внутри **одного целочисленного значения**, используя отдельные биты.

Каждый флаг соответствует **одному биту**.

---

## 2. Почему удобно использовать enum для флагов

- имена вместо «магических чисел»
    
- читабельность
    
- логическая группировка флагов
    
- компиляторная проверка
    

```cpp
enum Permissions {
    Read,
    Write,
    Execute
};
```

❌ Плохо — значения не являются битами.

---

## 3. Почему значения должны быть степенями двойки

Каждый бит в числе — это **степень двойки**:

|Бит|Значение|
|---|---|
|0|1 (2⁰)|
|1|2 (2¹)|
|2|4 (2²)|
|3|8 (2³)|

Если флаг = `2^n`, то он занимает **ровно один бит**.

✔ Флаги можно **комбинировать**  
✔ Проверка выполняется через `&`  
✔ Нет пересечений

---

## 4. Правильное объявление enum-флагов

```cpp
enum Permissions {
    None    = 0,
    Read    = 1 << 0, // 0001
    Write   = 1 << 1, // 0010
    Execute = 1 << 2  // 0100
};
```

---

## 5. Принцип работы битовых операций

### Побитовое ИЛИ `|` — установка флага

```cpp
int p = None;
p = p | Read;   // установить Read
p |= Write;     // установить Write
```

Биты:

```
0000 | 0001 = 0001
0001 | 0010 = 0011
```

---

### Побитовое И `&` — проверка флага

```cpp
if (p & Read) {
    // флаг Read установлен
}
```

Если бит установлен → результат ≠ 0.

---

### Побитовое НЕ `~` + И — очистка флага

```cpp
p &= ~Write;
```

---

### Побитовое XOR `^` — переключение флага

```cpp
p ^= Execute; // включить или выключить
```

---

## 6. Полный пример

```cpp
#include <iostream>

enum Permissions {
    None    = 0,
    Read    = 1 << 0,
    Write   = 1 << 1,
    Execute = 1 << 2
};

int main() {
    int perms = None;

    perms |= Read | Write;

    if (perms & Read)
        std::cout << "Read allowed\n";

    perms &= ~Write;

    if (!(perms & Write))
        std::cout << "Write denied\n";
}
```

---

## 7. Почему нельзя использовать обычные значения (0,1,2,3…)

```cpp
enum Bad {
    A = 0,
    B = 1,
    C = 2
};
```

Комбинация:

```cpp
B | C = 1 | 2 = 3
```

Но `3` **не соответствует одному флагу** → неоднозначность.

---

## 8. enum class + битовые флаги

Лучше использовать `enum class` + перегрузку операторов.

```cpp
enum class Permissions {
    None    = 0,
    Read    = 1 << 0,
    Write   = 1 << 1,
    Execute = 1 << 2
};
```

Перегрузка:

```cpp
inline Permissions operator|(Permissions a, Permissions b) {
    return static_cast<Permissions>(
        static_cast<int>(a) | static_cast<int>(b)
    );
}
```

---

## 9. Проверка флагов с enum class

```cpp
Permissions p = Permissions::Read | Permissions::Write;

if ((p & Permissions::Read) != Permissions::None) {
    // Read установлен
}
```

---

## 10. Типичные ошибки студентов

❌ Флаги не являются степенями двойки  
❌ Проверка == вместо `&`  
❌ Использование `enum` без `None = 0`  
❌ Смешивание enum class и int без cast

---

## 11. Краткое резюме

- Битовые флаги хранят несколько состояний в одном числе
    
- Каждый флаг = один бит = степень двойки
    
- `|` — установить
    
- `&` — проверить
    
- `~` + `&` — очистить
    
- `^` — переключить
    
- enum делает код читаемым и безопасным
    
