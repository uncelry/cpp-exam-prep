Разберём тему **`union` в C++** подробно и системно.

---

# 1. Что такое `union`

`union` — это пользовательский тип данных, в котором **все члены занимают одну и ту же область памяти**.

То есть:

- храниться может **только одно значение за раз**
    
- все поля «накладываются» друг на друга
    

---

## Пример

```cpp
union Data {
    int i;
    float f;
    char c;
};
```

Здесь `i`, `f` и `c` используют **один и тот же участок памяти**.

---

# 2. Как определяется размер union

Размер `union` равен:

> размеру самого большого члена + возможное выравнивание (alignment)

### Пример

```cpp
union Example {
    int i;     // 4 байта
    double d;  // 8 байт
    char c;    // 1 байт
};
```

Размер будет **8 байт**, потому что `double` — самый большой тип.

---

# 3. Как хранятся элементы

Все члены:

- располагаются по одному и тому же адресу
    
- используют одну и ту же память
    

Схематично:

```
|-------- 8 байт памяти --------|
^ i
^ d
^ c
```

Запись в один член **перезаписывает данные других**.

---

# 4. Активный член (active member)

**Активный член** — это последний член `union`, в который было записано значение.

Пример:

```cpp
Data d;
d.i = 10;   // активный член — i
d.f = 3.14; // теперь активный член — f
```

После записи в `f`:

- `i` больше не является корректным
    
- активным считается `f`
    

---

# 5. Почему чтение неактивного члена — Undefined Behavior (UB)

После записи в один член:

- объект считается сконструированным только для этого типа
    
- другой тип не существует в этой памяти
    

Пример:

```cpp
Data d;
d.i = 10;
std::cout << d.f; // ❌ UB
```

Почему это UB?

1. Тип объекта в памяти — `int`
    
2. Мы пытаемся интерпретировать память как `float`
    
3. Это нарушает строгие правила aliasing
    
4. Стандарт не гарантирует корректность
    

---

# 6. Исключение: чтение через `char`

Разрешено читать представление объекта через `char` / `unsigned char`.

Это используется для:

- сериализации
    
- работы с байтами
    

---

# 7. Особенности union в C++

В отличие от C:

- union может содержать классы
    
- но только один член может быть активен
    
- если есть нетривиальные типы — нужно вручную управлять конструктором и деструктором
    

Пример:

```cpp
union U {
    std::string s;
    int i;

    U() { new(&s) std::string(); }
    ~U() { s.~basic_string(); }
};
```

⚠ Требует ручного управления временем жизни.

---

# 8. Зачем нужен union

### 1) Экономия памяти

```cpp
struct Variant {
    int type;
    union {
        int i;
        double d;
    };
};
```

### 2) Реализация variant-подобных структур

(До появления `std::variant`)

### 3) Низкоуровневое программирование

- драйверы
    
- протоколы
    
- embedded
    

---

# 9. Проблемы union

❌ Нет автоматического контроля активного члена  
❌ Легко получить UB  
❌ Сложно управлять нетривиальными типами

Поэтому в современном C++ чаще используют:

```
std::variant
```

---

# 10. Пример безопасного использования

```cpp
#include <iostream>

union Number {
    int i;
    float f;
};

int main() {
    Number n;
    n.i = 42;

    std::cout << n.i << std::endl; // корректно
}
```

---

# 11. Краткое резюме

- `union` — все члены разделяют одну память
    
- размер = размер самого большого члена
    
- хранится только один активный член
    
- активный член — последний записанный
    
- чтение неактивного члена = Undefined Behavior
    
- используется в низкоуровневом коде
    
- в современном C++ часто заменяется `std::variant`
    
