В C++ **объявление** и **определение** функций класса — это разные этапы, которые часто разводят по разным файлам (`.h` / `.hpp` и `.cpp`). Это важно для архитектуры, компиляции и понимания языка.

---

## 1. Объявление функций класса

**Объявление** говорит компилятору:

* что такая функция существует
* как она называется
* какие у неё параметры и возвращаемый тип
* к какому классу она относится

Но **не говорит, что именно она делает**.

### Пример объявления внутри класса

```cpp
class User {
public:
    User(int age);        // объявление конструктора
    int getAge() const;   // объявление метода
    void setAge(int age); // объявление метода

private:
    int age_;
};
```

Что здесь происходит:

* тело функций отсутствует
* компилятор знает сигнатуры
* память под объект уже может быть рассчитана

---

## 2. Определение функций класса

**Определение** — это реализация функции (её тело).

### Определение вне класса

```cpp
User::User(int age) : age_(age) {}

int User::getAge() const {
    return age_;
}

void User::setAge(int age) {
    age_ = age;
}
```

Ключевые моменты:

* используется `ClassName::`
* сигнатура должна **в точности совпадать** с объявлением
* `const`, `noexcept`, `&`, `&&` — всё должно совпадать

---

## 3. Объявление + определение внутри класса

Если функция **определена прямо в классе**, она автоматически становится `inline`.

```cpp
class User {
public:
    int getAge() const {
        return age_;
    }

private:
    int age_;
};
```

Это:

* допустимо
* удобно для коротких методов
* часто используется в заголовках, шаблонах, STL

⚠️ `inline` здесь — не про оптимизацию, а про **правило одного определения (ODR)**.

---

## 4. Заголовочные и cpp-файлы (классическая схема)

### user.h

```cpp
#pragma once

class User {
public:
    User(int age);
    int getAge() const;
    void setAge(int age);

private:
    int age_;
};
```

### user.cpp

```cpp
#include "user.h"

User::User(int age) : age_(age) {}

int User::getAge() const {
    return age_;
}

void User::setAge(int age) {
    age_ = age;
}
```

### Зачем так делают

* уменьшается время компиляции
* чёткое разделение интерфейса и реализации
* меньше зависимостей между файлами

---

## 5. Конструкторы и деструкторы

### Объявление

```cpp
class File {
public:
    File(const char* name);
    ~File();
};
```

### Определение

```cpp
File::File(const char* name) {
    // открыть файл
}

File::~File() {
    // закрыть файл
}
```

❗ Деструктор:

* не имеет параметров
* не возвращает значение
* может быть `virtual`

---

## 6. Const-методы — важная деталь

`const` после сигнатуры — **часть объявления**.

```cpp
class A {
public:
    int f() const;
};
```

Определение **обязано** повторить `const`:

```cpp
int A::f() const {
    return 42;
}
```

Иначе — **ошибка компиляции**.

---

## 7. Перегрузка методов и объявления

```cpp
class Printer {
public:
    void print(int x);
    void print(double x);
};
```

Определения:

```cpp
void Printer::print(int x) {
    std::cout << x;
}

void Printer::print(double x) {
    std::cout << x;
}
```

Сигнатура = имя + параметры + `const` / `&` / `&&`

---

## 8. Inline-функции и ODR

Если функция определена в заголовке и используется в нескольких `.cpp`, она должна быть:

* `inline`, **или**
* шаблонной, **или**
* определённой внутри класса

Иначе:

> multiple definition error

---

## 9. Шаблоны — особый случай

Шаблонные функции **почти всегда определяют в заголовке**.

```cpp
template <typename T>
class Box {
public:
    T get() const { return value_; }

private:
    T value_;
};
```

Причина:

* шаблоны инстанцируются во время компиляции
* компилятору нужно видеть реализацию

---

## 10. Частые ошибки

### ❌ Не совпадает сигнатура

```cpp
// объявление
int f() const;

// определение
int f() { } // ошибка
```

### ❌ Забыли ClassName::

```cpp
int getAge() { } // ошибка
```

### ❌ Определение в .h без inline

```cpp
int f() { return 1; } // multiple definition
```

---

## Краткое резюме

* **Объявление** — сообщает о существовании функции
* **Определение** — реализует её
* Можно:

  * объявить в классе, определить вне
  * определить сразу в классе
* `const`, `noexcept`, `&` — часть сигнатуры
* Шаблоны почти всегда определяют в заголовках
* Разделение `.h / .cpp` — хорошая практика для не-шаблонных классов
